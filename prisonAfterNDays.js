// 8 间牢房排成一排，每间牢房不是有人住就是空着。

// 每天，无论牢房是被占用或空置，都会根据以下规则进行更改：

// 如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。
// 否则，它就会被空置。
// （请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）

// 我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。

// 根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。

//  

// 示例 1：

// 输入：cells = [0,1,0,1,1,0,0,1], N = 7
// 输出：[0,0,1,1,0,0,0,0]
// 解释：
// 下表概述了监狱每天的状况：
// Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
// Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
// Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
// Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
// Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
// Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
// Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
// Day 7: [0, 0, 1, 1, 0, 0, 0, 0]

// 思路： 反正第一件事就是 比较 cell[j -1 ] = cell [j+1];

// 维持一个队列，判断是否循环了 循环数是多少位

const prisonAfterNDays = (cells, N) => {
    let list = []; // 维持修改的列表
    let num = N;
    for (let i = 1; i <= N; i++) {
        let arr = [];
        for (let j = 0; j < cells.length; j++) {
            if (j === 0 || j === cells.length) {
                arr[j] = 0;
            } else {
                if (cells[j - 1] == cells[j + 1]) {
                    arr[j] = 1;
                } else {
                    arr[j] = 0;
                }
            }
        }
        list.push(arr);
        cells = arr; // 下次循环用
        if (i > 1 && arr.join('') === list[0].join('')) {
            num = i - 1;
            break;
        }
    }

    let n = N % num;
    if (n === 0) {
        return list[num - 1];
    } else {
        // N = 15, num = 14 所欲低0个
        return list[n - 1]
    }


}
